# 基于改进哈夫曼编码的图像压缩系统 (Image Compression via Improved Huffman Coding)

## 📖 项目简介

本项目是“算法设计与分析”课程的期末大作业。项目实现了一个完整的图像压缩系统，不仅实现了经典的**哈夫曼编码 (Huffman Coding)**，还引入了**差分编码 (Delta Encoding)**、**通道分离 (Planar Separation)** 和**标量量化 (Scalar Quantization)** 等现代图像压缩技术。

该系统支持**无损压缩**和**有损压缩**两种模式，并提供了一套自动化的实验脚本，用于分析不同量化因子（Q-Factor）下的**压缩率**与**图像质量 (PSNR)** 之间的权衡关系（Rate-Distortion Trade-off）。

## 🚀 核心特性

- **混合编码架构**：`通道分离` -> `标量量化` -> `差分编码` -> `哈夫曼编码`。
- **支持多种格式**：支持 BMP, PNG, JPG 等常见图像格式（推荐使用 BMP 作为原始数据进行测试）。
- **可变压缩率**：通过调整量化因子 $Q$，实现从无损 ($Q=1$) 到高压缩比 ($Q=50$) 的平滑过渡。
- **自动化评测**：内置实验脚本，自动遍历参数，生成 CSV 数据报告及双 Y 轴分析图表。
- **鲁棒性设计**：解决了差分编码中的“基准值丢失”问题，确保解压图像无色偏。

## 📂 项目结构

Plaintext

```
Huffman-Compression/
├── huffman.py              # 核心算法类：实现哈夫曼树构建、编码生成、差分与量化逻辑
├── utils.py                # 工具类：图像IO处理、通道分离/合并、PSNR计算
├── main.py                 # 主程序：单次运行压缩与解压，适合调试
├── experiment_runner.py    # 实验脚本：批量跑图、生成数据报表、绘制分析图
├── convert_to_bmp.py       # 辅助脚本：将图片转换为未压缩的 BMP 格式作为基准
├── data/
│   ├── input/              # [输入] 请将原始图片放入此处
│   └── output/             # [输出] 程序自动生成压缩包(.bin)和还原图(.jpg)
├── requirements.txt        # 依赖列表
└── README.md               # 项目说明文档
```

## 🛠️ 环境依赖与安装

本项目基于 Python 3 开发，核心依赖包括 `numpy` (矩阵运算加速) 和 `pillow` (图像处理)。

Bash

```
# 安装依赖
pip install numpy pillow matplotlib pandas
```

## ⚡ 快速开始

### 1. 准备数据

建议使用 BMP 格式 作为输入，因为它是未经压缩的原始数据，能最直观地反映本算法的压缩能力。

将你的图片放入 data/input/ 目录下。如果没有 BMP，可以使用以下脚本转换：

Bash

```
python convert_to_bmp.py
```

### 2. 运行主程序 (单次测试)

修改 `main.py` 中的 `Q_FACTOR` 参数来体验不同的压缩效果。

Bash

```
python main.py
```

- **Q=1**: 无损压缩模式。
- **Q=10**: 推荐的有损模式，平衡了压缩率与画质。

运行后，控制台将输出压缩率和 PSNR，结果文件保存在 `data/output/`。

### 3. 运行自动化实验 (批量分析)

该脚本会自动遍历一系列 $Q$ 值 ($1, 5, 10, 20, 50...$)，并生成分析图表。

Bash

```
python runner.py
```

- 生成的 CSV 数据表：`experiment_results.csv`
- 生成的趋势图：`plot_[图片名].png`

## 🧠 算法原理与优化

### 1. 预处理：通道分离 (Planar Separation)

将常见的 `RGBRGB...` 像素排列转换为 `RRR...GGG...BBB...`。

- **目的**：提高相邻像素的相关性，使后续的差分编码更高效。

### 2. 有损优化：标量量化 (Scalar Quantization)

$$P_{new} = \lfloor P_{old} / Q \rfloor$$

- **目的**：减少像素值的离散程度，大幅降低信源熵。$Q$ 值越大，丢失精度越多，但压缩率越高。

### 3. 去除空间冗余：差分编码 (Delta Encoding)

$$D_i = P_i - P_{i-1} \quad (P_0 \text{保留绝对值})$$

- **目的**：利用图像的空间局部性，将宽分布的像素值转化为集中在 0 附近的差分值（拉普拉斯分布），极适合哈夫曼编码。

### 4. 熵编码：哈夫曼编码 (Huffman Coding)

基于统计频率构建二叉树，为高频出现的差分值（如 0, 1, -1）分配极短的二进制编码。

## 📊 实验结果示例

| **图片类型** | **原始大小 (KB)** | **压缩后 (KB)** | **真实压缩率** | **PSNR (dB)** | **备注**          |
| ------------ | ----------------- | --------------- | -------------- | ------------- | ----------------- |
| **Lena.bmp** | 768.0             | 480.2           | **37.5%**      | $\infty$      | 无损模式 ($Q=1$)  |
| **Lena.bmp** | 768.0             | 185.3           | **75.8%**      | 38.5          | 有损模式 ($Q=10$) |

